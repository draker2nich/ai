<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ë—ã—Å—Ç—Ä—ã–π —Ç–µ—Å—Ç 3D –º–æ–¥–µ–ª–∏</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background: #1a1a2e;
            color: white;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
        }
        .success { color: #4ade80; }
        .error { color: #f87171; }
        .warning { color: #fbbf24; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <h3>–¢–µ—Å—Ç –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏</h3>
        <div id="status">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const statusDiv = document.getElementById('status');
        
        function log(message, type = 'info') {
            const color = type === 'success' ? 'success' : type === 'error' ? 'error' : type === 'warning' ? 'warning' : '';
            statusDiv.innerHTML += `<div class="${color}">${message}</div>`;
            console.log(message);
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã
        log('–°–æ–∑–¥–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã...');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        const camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);

        // –û—Å–≤–µ—â–µ–Ω–∏–µ
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(5, 10, 7);
        scene.add(directionalLight);

        log('‚úÖ –°—Ü–µ–Ω–∞ —Å–æ–∑–¥–∞–Ω–∞', 'success');

        // –ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏
        log('–ó–∞–≥—Ä—É–∑–∫–∞ /models/sweatshirt.glb...');
        const loader = new GLTFLoader();

        loader.load(
            '/models/sweatshirt.glb',
            (gltf) => {
                log('‚úÖ –ú–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞!', 'success');
                const model = gltf.scene;

                // –ê–Ω–∞–ª–∏–∑ –º–æ–¥–µ–ª–∏
                let meshCount = 0;
                let vertexCount = 0;
                let hasUV = false;

                model.traverse((child) => {
                    if (child.isMesh) {
                        meshCount++;
                        if (child.geometry.attributes.position) {
                            vertexCount += child.geometry.attributes.position.count;
                        }
                        if (child.geometry.attributes.uv) {
                            hasUV = true;
                        }
                    }
                });

                log(`üìä –ú–µ—à–µ–π: ${meshCount}`, 'info');
                log(`üìä –í–µ—Ä—à–∏–Ω: ${vertexCount}`, 'info');
                log(`üìä UV-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã: ${hasUV ? '‚úÖ –ï–°–¢–¨' : '‚ùå –ù–ï–¢'}`, hasUV ? 'success' : 'error');

                // –†–∞–∑–º–µ—Ä—ã
                const box = new THREE.Box3().setFromObject(model);
                const size = new THREE.Vector3();
                box.getSize(size);
                
                log(`üìê –†–∞–∑–º–µ—Ä: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`, 'info');

                // –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ
                const maxDim = Math.max(size.x, size.y, size.z);
                const targetSize = 3.5;
                const scale = targetSize / maxDim;
                
                model.scale.setScalar(scale);
                log(`üîß –ú–∞—Å—à—Ç–∞–±: ${scale.toFixed(3)}x`, 'success');

                // –¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ
                const center = new THREE.Vector3();
                box.getCenter(center);
                model.position.x = -center.x * scale;
                model.position.y = -center.y * scale;
                model.position.z = -center.z * scale;

                scene.add(model);
                log('‚úÖ –ú–æ–¥–µ–ª—å –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ —Å—Ü–µ–Ω—É!', 'success');
                log('üñ±Ô∏è –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –º—ã—à—å –¥–ª—è –≤—Ä–∞—â–µ–Ω–∏—è', 'info');

                // –í—Ä–∞—â–µ–Ω–∏–µ
                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };
                const rotation = { x: 0, y: 0 };

                renderer.domElement.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    rotation.y += deltaX * 0.005;
                    rotation.x += deltaY * 0.005;
                    rotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, rotation.x));
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                // –ê–Ω–∏–º–∞—Ü–∏—è
                function animate() {
                    requestAnimationFrame(animate);
                    model.rotation.x = rotation.x;
                    model.rotation.y = rotation.y;
                    renderer.render(scene, camera);
                }
                animate();
            },
            (progress) => {
                const percent = Math.round((progress.loaded / progress.total) * 100);
                log(`‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞: ${percent}%`);
            },
            (error) => {
                log(`‚ùå –û–®–ò–ë–ö–ê: ${error.message}`, 'error');
                log('–ü—Ä–æ–≤–µ—Ä—å—Ç–µ —á—Ç–æ —Ñ–∞–π–ª —Å—É—â–µ—Å—Ç–≤—É–µ—Ç: public/models/sweatshirt.glb', 'error');
            }
        );

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
